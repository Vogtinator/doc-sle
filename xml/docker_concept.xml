<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xml:id="cha.docker.conceptoverview" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.0"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Conceptual Overview</title>
 <para>
  &deng; is a lightweight virtualization solution to run multiple virtual units
  (containers) simultaneously on a single control host. Containers are isolated
  with Kernel Control Groups (<xref linkend="vle.docker.cgroup"/>) and
  <xref linkend="vle.docker.namespace"/>.
 </para>
 <para>
  Full virtualization solutions such as &xen;, &kvm;, or &libvirt; are based on
  the processor simulating a complete hardware environment and controlling the
  virtual machines. However, &deng; only provides operating system-level
  virtualization where the Linux kernel controls isolated containers.
 </para>
 <sect1 xml:id="sec.docker.installation.terminology_deng">
  <title>&deng; Terminology</title>
  <remark>toms 2019-02-04: check with Tanja, if you need the full title or
  if "Terminology" is enough.</remark>
  <para>
   Before going into detail about &deng;, let us define some of the terms used:
  </para>
  <variablelist>
   <varlistentry>
    <term>Container</term>
    <listitem>
     <remark>toms 2019-02-04: according to
      https://docs.docker.com/glossary/?term=container a container consists
      of a) a Docker image, b) an executation environment, and c) a set of
      instructions. Maybe add that info after your first sentence?
     </remark>
     <para>
      A <emphasis>container</emphasis> is a running<remark>toms 2019-02-04:
       and a idle/stopped image is not a container? ;) Isn't that term a bit
       too restrictive?</remark> instance based on a
      particular &docker; <xref linkend="Docker_Image"/>. Each
      <emphasis>container</emphasis> can be distinguished by a unique container
      ID.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="vle.docker.cgroup">
    <term>Control group</term>
    <listitem>
     <para>
      <emphasis>Control groups</emphasis>, also called
      <literal>cgroups</literal>, is a Linux kernel feature that allows
      aggregating or partitioning tasks (processes) and all their children into
      hierarchically organized groups to isolate resources.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Dockerfile</term>
    <listitem>
     <para>
      <remark>toms 2019-02-04: The description is misleading IMHO. It gives
       it a different spin. ;)
      According to https://docs.docker.com/engine/reference/builder/
      "A Dockerfile is a text document that contains all the commands a user
      could call on the command line to assemble an image. Using docker build
      users can create an automated build that executes several command-line
      instructions in succession."
      I would suggest to rephrase your explanation.
      </remark>
      A <emphasis>Dockerfile</emphasis> stores changes made on top of the base
      image. The <xref linkend="Docker_engine"/> reads instructions in the
      <emphasis>Dockerfile</emphasis> and builds a new image according to the
      instructions.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="Docker_engine">
    <term>&deng;</term>
    <listitem>
     <para>
      &deng; is a server-client type application that performs all
      tasks related to virtual machines. &deng; comprises the
      following:
     </para>
     <itemizedlist>
      <listitem>
       <formalpara>
        <title>CLI Client:</title>
        <para>
         Enables you to communicate with the daemon. If the daemon is running
         on a different machine than the CLI client, the CLI client can
         communicate by using network sockets or the REST API provided by
         &deng;.
        </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
        <title>Daemon:</title>
        <para>
         The server side of &deng; manages all &docker; objects (images,
         containers, network connections used by containers, etc.).
        </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
        <title>REST API:</title>
        <para>
         Applications can use this API to communicate directly with the daemon.
        </para>
       </formalpara>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="Docker_Image">
    <term>Image</term>
    <listitem>
     <para>
      An <emphasis>image</emphasis> is a read-only template<remark>toms 2019-02-04: 
      template sounds a bit strange in this context.
      On Quora.com, I've found an interesting definition:
      "An image is a compressed, self-contained piece of software which has
      to be unwrapped in order to use the functionality." Maybe you can add
      it somehow.</remark> used to create a
      <emphasis>virtual machine</emphasis> on the host server. A &docker; image is
      made by a series of layers built one over the other. Each layer
      corresponds to a permanent change, for example an update of an
      application.
      <remark>toms 2019-02-04: The following sentence is dangerous and
      misleading IMHO. The term "changes" does not relate to a Dockerfile.
      That file is used merely as a kind of "build recipe".
      I would propose to rephase/move the sentence at the beginning of this
      paragraph:
      "An image is a read-only template used to create a virtual machine on
      the host server. Such an image is represented/build by using a
      Dockerfile which acts as an "recipe". A Docker image is..."
      </remark>
      The changes are stored in a file called a
      <emphasis>Dockerfile</emphasis>. For more details see
      <link xlink:href="http://docs.docker.com/engine/reference/glossary#image">the
       official Docker documentation</link>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="vle.docker.namespace">
    <term>Namespace</term>
    <listitem>
     <para>
      Used by &deng; for its containers to isolate resources reserved for
      particular containers from other containers or the host system.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Orchestration</term>
    <listitem>
     <para>
      In a production environment you typically need a cluster with many
      containers on each cluster node. The containers must cooperate and you
      need a framework that enables you to manage the containers automatically.
      The act of automatic container management is called <emphasis>container
      orchestration</emphasis> and is typically handled by Kubernetes.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Registry</term>
    <listitem>
     <para>
      A <emphasis>registry</emphasis> is storage for already created images. It
      typically contains several <emphasis>repositories</emphasis> There are two
      types of registry:
     </para>
     <itemizedlist>
      <listitem>
       <formalpara>
        <title>Private Registry:</title>
        <para>
        these are accessible for particular users or from a
        particular private network.
        </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
        <title>Public Registry:</title>
        <para>
        where everyone (usually registered) can download and
        use images. A typical public registry is
        <link xlink:href="https://hub.docker.com/">Docker Hub</link>.
        </para>
       </formalpara>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Repository</term>
    <listitem>
     <para>
      A <emphasis>repository</emphasis> is storage in a
      <emphasis>registry</emphasis> that stores a different version of a
      particular image. You can pull or push images from or to a repository.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <remark>toms 2019-02-04: I would suggest to define some more terms which
  I think are important: layer &amp; tag.</remark>
 </sect1>
 <sect1 xml:id="sec.docker.concept.advantages_deng">
  <title>Advantages of &deng;</title>
  <para>
   &deng; provides you with the following advantages:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Isolates applications and operating systems through containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Manages allocation of resources in real time, leading to a near-native performance.
    </para>
   </listitem>
   <listitem>
    <para>
     Uses cgroups to control network interfaces and resources available inside containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Versioning of images.
    </para>
   </listitem>
   <listitem>
    <para>
     Allows building new images based on existing ones.
    </para>
   </listitem>
   <listitem>
    <para>
     Provides you with container orchestration.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.docker.concept.limitations_deng">
  <title>Limitations of &deng;</title>
  <para>
   On the other hand, &deng; has the following limitations:
  </para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Containers run inside the host system's kernel and cannot use a different
     kernel.
    </para>
   </listitem>
   <listitem>
    <para>
     Only allows Linux <emphasis>guest</emphasis> operating systems.
    </para>
   </listitem>
   <listitem>
    <para>
     &deng; is not a full virtualization stack like &xen;, &kvm;, or &libvirt;.
    </para>
   </listitem>
   <listitem>
    <para>
     Security depends on the host system. Refer to the
     <link xlink:href="http://docs.docker.com/articles/security/">official
      security documentation</link> for more details.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.docker.concept.images-applications">
  <title>&docker; Images of Applications</title>
  <para>
  &deng; is a technology that can help minimize resources used to run or
  build applications. There are several types of applications that are
  suitable to run inside a &docker; container, like daemons, Web pages or
  applications that expose ports for communication. You can use &deng; to
  automate building and deployment processes by adding the build process
  into a &docker; image, then building the image and then running containers
  based on that image.
 </para>
 <sect2 xml:id="sec.docker.concept.images-applications.run-inside">
  <title>Advantages of Running Applications Inside &docker; Containers</title>
  <para>
   Running an application inside a &docker; container has the
   following advantages:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     You can minimize the runtime environment of the application by adding just
     the required processes and applications to the &docker; image.
    </para>
   </listitem>
   <listitem>
    <para>
     The image with your application is portable across machines also with
     different Linux host systems.
    </para>
   </listitem>
   <listitem>
    <para>
     You can share the image of your application by using a repository.
    </para>
   </listitem>
   <listitem>
    <para>
     Within the container, you can use package versions that are different from
     the ones used on the host system without causing dependency problems.
    </para>
   </listitem>
   <listitem>
    <para>
     You can run several instances of the same application that are completely
     independent from each other.
    </para>
   </listitem>
  </itemizedlist>
  </sect2>
  <sect2 xml:id="sec.docker.concept.images-applications.build">
   <title>Advantages of &deng; to Build Applications</title>
   <para>
    Using &deng; to build applications has the following advantages:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      You can prepare a complete build image.
     </para>
    </listitem>
    <listitem>
     <para>
      Your build always runs in the same environment.
     </para>
    </listitem>
    <listitem>
     <para>
      Developers can test their code in the same environment that is used in
      production.
     </para>
    </listitem>
    <listitem>
     <para>
      You can set up an automated building process.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.docker.concept.architecture_deng">
  <title>&deng; Architecture</title>
  <para>
   &deng; uses a client/server architecture. You can use the <emphasis>CLI
    client</emphasis> to communicate with the <emphasis>daemon</emphasis>. The
   <emphasis>daemon</emphasis> then performs operations with containers and
   manages images locally or in the registry. The <emphasis>CLI client</emphasis>
   can run on the same server as the host daemon or on a different machine. The
   <emphasis>CLI client</emphasis> communicates with the
   <emphasis>daemon</emphasis> by using network sockets. The architecture is
   depicted in <xref linkend="Docker_architecture"/>.
  </para>
  <remark>toms 2019-02-04: The font size in the following picture is too
   small. Please increase the font size with Inkscape so it's more readable.
  </remark>
  <figure xml:id="Docker_architecture">
   <title>The &deng; Architecture</title>
   <mediaobject>
    <imageobject>
     <imagedata fileref="docker_architecture.png" format="PNG" width="95%"/>
    </imageobject>
   </mediaobject>
  </figure>
 </sect1>

 <sect1 xml:id="sec.docker.concept.definition_dreg">
  <title>&dreg;</title>

  <para>
   The &dreg; is an open-source project created by Docker Inc. It
   allows the storage and retrieval of &docker; images. By running a local
   instance of the &dreg;, it is possible to completely avoid usage of &dhub;.
  </para>

  <para>
   &dreg; is also used by &dhub;. However, &dhub;,
   as seen from the user perspective, is made of the following parts at least:
  </para>

  <remark>toms 2019-02-05: Not sure if it is better to have separate sections
  about terminology instead of one single one at the beginning.
  Maybe you need to rephrase it to make it clear that the terms below refers
  to the Docker Registry. Discuss with Tanja. :)
  </remark>
  <sect2 xml:id="sec.docker.concept.terminology_dreg">
   <title>&dreg; Terminology</title>
   <variablelist>
    <varlistentry>
     <term>
      User Interface (UI)
     </term>
     <listitem>
      <para>
       Accessed by users with their browser. Users can browse the contents of
       &dhub; either manually or by using a search feature. It also allows to
       create organizations made by different users.
      </para>
      <para>
       This component is closed-source.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Authentication Component
     </term>
     <listitem>
      <para>
       Used to protect the images stored inside of &dhub;. It validates all
       push, pull and search requests.
      </para>
      <para>
       This component is closed-source.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Storage Back-End
     </term>
     <listitem>
      <para>
       Where &docker; images are sent and downloaded from. It is provided by
       &dreg;.
      </para>
      <para>
       This component is open-source.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
  <sect2 xml:id="sec.docker.concept.limitations_dreg">
   <title>Limitations of &dreg;</title>

   <para>
    The &dreg; has two major limitations:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      It lacks any form of authentication. That means everybody with access to
      the &dreg; can push and pull images to it. That also includes the
      possibility to overwrite already existing images.
     </para>
    </listitem>
    <listitem>
     <para>
      There is no way to see which images have been pushed to the &dreg;.
      You need to manually take notes of what is being stored inside
      of it. There is also no search functionality, which makes collaboration
      harder.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
</chapter>
